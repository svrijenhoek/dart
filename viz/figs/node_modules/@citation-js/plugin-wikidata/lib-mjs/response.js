import { simplify } from 'wikidata-sdk';
import { parse as fetch, parseAsync as fetchAsync } from './api.js';
import { parse as getUrls } from './id.js';
const SIMPLIFY_OPTS = {
  keepQualifiers: true,
  timeConverter: 'simple-day'
};
const FETCH_PLACE = {
  P17: null
};
const FETCH_PUBLISHER = {
  P740: FETCH_PLACE,
  P159: FETCH_PLACE
};
const FETCH_ADDITIONAL = {
  P50: null,
  P57: null,
  P86: null,
  P98: null,
  P110: null,
  P655: null,
  P1817: null,
  P921: {
    P50: null
  },
  P407: null,
  P364: null,
  P123: FETCH_PUBLISHER,
  P629: {
    P50: null,
    P123: FETCH_PUBLISHER
  },
  P437: null,
  P186: null,
  P179: {
    P98: null
  },
  P1433: {
    P4745: {
      P276: FETCH_PLACE
    }
  },
  P361: {
    P50: null
  }
};

function flat(array, part) {
  array.push(...part);
  return array;
}

function collectAdditionalIds(entity, needed) {
  if (!needed) {
    return [];
  }

  entity._needed = Object.assign(entity._needed || {}, needed);
  return Object.keys(entity.claims).filter(prop => prop in needed).map(prop => entity.claims[prop].map(({
    value
  }) => value.id || value)).reduce(flat, []);
}

function completeResponse(entities, old) {
  if (!old) {
    const allIds = [];

    for (const id in entities) {
      const ids = collectAdditionalIds(entities[id], FETCH_ADDITIONAL);

      for (const id of ids) {
        if (!allIds.includes(id)) {
          allIds.push(id);
        }
      }
    }

    return allIds;
  }

  const ids = [];

  for (const id of old) {
    const entity = entities[id];

    if (!entity._needed) {
      continue;
    }

    for (const prop in entity.claims) {
      if (prop in entity._needed) {
        for (const claim of entity.claims[prop]) {
          if (claim.value && claim.value.id) {
            continue;
          }

          claim.value = entities[claim.value];
          ids.push(...collectAdditionalIds(claim.value, entity._needed[prop]));
        }
      }
    }

    delete entity._needed;
  }

  return ids;
}

function simplifyEntities(entities) {
  return simplify.entities(entities, SIMPLIFY_OPTS);
}

function initLoopState(entities, cache) {
  return {
    needed: completeResponse(cache),
    incomplete: Object.keys(entities)
  };
}

function filterIdsAndGetUrls(needed, cache) {
  const shouldFetch = needed.filter((id, i) => !(id in cache) && needed.indexOf(id) === i);
  return getUrls(shouldFetch);
}

function addItemsToCache(response, cache) {
  const {
    entities
  } = JSON.parse(response);
  Object.assign(cache, simplifyEntities(entities));
}

function updateLoopState(state, cache) {
  return {
    needed: completeResponse(cache, state.incomplete),
    incomplete: state.needed
  };
}

function finalizeItems(entities, cache) {
  return Object.keys(entities).map(id => cache[id]);
}

export function fillCache(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);

  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    urls.map(url => addItemsToCache(fetch(url), cache));
    state = updateLoopState(state, cache);
  }

  return cache;
}
export function parse(entities) {
  const cache = fillCache(entities);
  return finalizeItems(entities, cache);
}
export async function fillCacheAsync(entities) {
  const cache = simplifyEntities(entities);
  let state = initLoopState(entities, cache);

  while (state.needed.length) {
    const urls = filterIdsAndGetUrls(state.needed, cache);
    await Promise.all(urls.map(async url => addItemsToCache(await fetchAsync(url), cache)));
    state = updateLoopState(state, cache);
  }

  return cache;
}
export async function parseAsync(entities) {
  const cache = await fillCacheAsync(entities);
  return finalizeItems(entities, cache);
}